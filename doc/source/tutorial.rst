Tutorial
========

CLUDA
-----

CLUDA is an abstraction layer on top of PyCuda/PyOpenCL.
Tigger's kernels are based on it, but it can be used by itself too, if you need a specialized kernel.

Computations, user point of view
--------------------------------

As an example, we will consider the matrix multiplication.

Transformations
---------------

Now let us assume you multiply complex matrices, but real and imaginary parts of your data is kept in separate arrays.
You could create elementwise kernels that would join your data into arrays of complex values, but this would require additional storage and additional calls to GPU.
Transformation API allows you to connect these transformations to the core computation --- matrix multiplication --- effectively adding the code into the main computation kernel and changing its signature.

- Elementwise pre- and post-processing can be attached to any kernel (derived from Computation class).
- Pre-processing is invoked when kernel reads from memory, and post-processing is invoked when kernel writes to memory.
  Pre-processing has to have only one output value, and post-processing has to have only one input value.
- The transformations are strictly elementwise (the user is limited by {store} and {load} macros, which do not let him specify the index).
- They can change variable types as long as there is a function that derives output type from input types (for load) or input types from output types (for store); by default these types are equal.
  Each transformation has to have both type derivations from input to output and from output to input.
  For example, if user calls prepare(), we will need to derive types "inside out", and with prepare_for() the derivation will go "outside-in".
  The library should check that all used types are actually supported by the videocard.
- Since the processing mechanism does not let us change the call signature (like adding out=None to opt for the result array being allocated during the call), we will have to have bot low-level call (with autogenerated signature) and high-level call (with maybe more convenient, but less flexible signature).
  Autogenerated signature contains only *args, with new parameters added to the end, and new arrays added in place of the ones they are generated from.
  If there are repetitions in the arg list, only the first encounter is left.

When computation has some processing attached to it, its signature changes.
